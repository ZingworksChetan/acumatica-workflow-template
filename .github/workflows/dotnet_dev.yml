name: deploy to Dev Template

on:
  workflow_call:
    inputs:
      build_no:
        required: true
        type: string
        description: 'Build number to deploy'
      branch:
        required: true
        type: string
        description: 'Release branch name triggering deployment'


jobs:
  build:
    runs-on: windows-latest
    environment: DEV
    outputs:
      zipName: ${{ steps.build.outputs.zipName }}

    env:    
      P_NAME:  ${{ vars.P_NAME }}
      DLL_BRANCH_2024R1: ${{ vars.DLL_BRANCH_2024R1 }}
      DLL_BRANCH_2025R1: ${{ vars.DLL_BRANCH_2025R1 }}
      SOLUTION: ${{ vars.P_NAME }}.sln     
      PROJECT: ${{ vars.P_NAME }}\${{ vars.P_NAME }}.csproj
      AC_BASE_URL: ${{ vars.AC_BASE_URL }}
      AC_USERNAME: ${{ vars.AC_USERNAME }}
      AC_PASSWORD: ${{ secrets.AC_PASSWORD }}
      PROJECT_DESCRIPTION: ${{ vars.PROJECT_DESCRIPTION }}
      PROJECT_LEVEL: ${{ vars.PROJECT_LEVEL }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log Environment Variables
        shell: pwsh
        run: |
          Write-Host "Logging environment variables:"
          Get-ChildItem Env: | ForEach-Object { Write-Host "$($_.Name)=$($_.Value)" }

      - name: Determine Variables from Branch
        id: vars
        shell: bash
        run: |
          BRANCH="${{ inputs.branch }}"
          echo "BRANCH=BRANCH" >> $GITHUB_ENV

          # Always same project name
          echo "PROJECT_NAME=${{ env.P_NAME }}" >> $GITHUB_ENV

          # Branch mapping based on on suffix
          if [[ "$BRANCH" == *24R1 ]]; then
            DLL_BRANCH="${{ env.DLL_BRANCH_2024R1 }}"
          elif [[ "$BRANCH" == *25R1 ]]; then
            DLL_BRANCH="${{ env.DLL_BRANCH_2025R1 }}"
          else
            echo "Unsupported branch: BRANCH"
            exit 1
          fi

          # Export into environment for later steps
          echo "DLL_BRANCH=$DLL_BRANCH" >> $GITHUB_ENV

          echo "Final DLL_BRANCH resolved as: $DLL_BRANCH"


      - name: Checkout DLL Repo
        uses: actions/checkout@v4
        with:
          repository: ZingworksChetan/acumatica-packages
          token: ${{ secrets.GH_PAT_TOKEN }}
          path: dlls
          ref: ${{ env.DLL_BRANCH }}

      - name: Copy DLLs from dll-store to project bin
        shell: pwsh
        run: |
          $dest = "${{ env.P_NAME }}\bin\Release"
          if (-Not (Test-Path -LiteralPath $dest)) {
            New-Item -ItemType Directory -Force -Path $dest | Out-Null
          }
          Copy-Item -Path "dlls\*.dll" -Destination $dest -Force

      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1.1

      - name: Build Project
        run: msbuild $env:PROJECT /p:Configuration=Release
        shell: pwsh
        env:
          PROJECT: ${{ env.P_NAME }}\${{ env.P_NAME }}.csproj
          NUGET_PACKAGES: ${{ github.workspace }}\.nuget\packages

      - name: Copy DLL to Customization Bin
        shell: pwsh
        run: |
          $projectName = "${{ env.P_NAME }}"
          $dllName = "${{ env.P_NAME }}.dll"

          #Full source path
          $source = Join-Path -Path $PWD.Path -ChildPath "$projectName\bin\Release"

          #Destination inside the Customizations folder
          $destination = Join-Path -Path $PWD.Path -ChildPath "Customizations\$projectName\Bin"

          Write-Host "Copying built DLL from: $source"
          Write-Host "Destination path: $destination"

          if (Test-Path -LiteralPath $source) {
           New-Item -ItemType Directory -Force -Path $destination | Out-Null

            $dllSourcePath = Join-Path $source $dllName
            Copy-Item -LiteralPath $dllSourcePath -Destination $destination -Force
            Write-Host "DLL copied to $destination"
          } else {
            Write-Host "Source path not found: $source"
          }

      - name: Build Customization Package
        id: build
        shell: pwsh
        run: |                    
          $zipName = "$($env:P_NAME)[${{ inputs.build_no }}]"
          echo "zipName=$zipName" >> $env:GITHUB_OUTPUT
          pwsh ./buildCustomization.ps1 $zipName

      - name: Upload ZIP Artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ steps.build.outputs.zipName }}
          path: build/*.zip

      - name: Run Publish to DEV
        shell: pwsh
        run: |
         ./publishCustomization.ps1 ${{ steps.build.outputs.zipName }}